# -*- coding: utf-8 -*-"""This file is part of PyFrac.Created by Haseeb Zia on Fri Dec 16 17:49:21 2017.Copyright (c) "ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE, Switzerland, Geo-Energy Laboratory", 2016-2019.All rights reserved. See the LICENSE.TXT file for more details.This file has been modified to study gas injection in borehole PGZ1002 for ANDRA.In this file, there is no injection line, no leakoff, no compressibility of the gas: this is the basic base case."""# importsimport numpy as npimport osfrom matplotlib import pyplot as plt# local importsfrom mesh_obj.mesh import CartesianMeshfrom solid.elasticity_kernels.isotropic_R0_elem import load_isotropic_elasticity_matrixfrom solid.solid_prop import MaterialPropertiesfrom fluid.fluid_prop import FluidPropertiesfrom properties import InjectionProperties, SimulationPropertiesfrom fracture_obj.fracture import Fracturefrom controller import Controllerfrom fracture_obj.fracture_initialization import Geometry, InitializationParametersfrom utilities.utility import setup_logging_to_console# setting up the verbosity level of the log at consolesetup_logging_to_console(verbosity_level='debug')"""This files is the base case for gas injection simulation of ANDRA experiments PGZ: no injection line, no leakoff, no pre-existing fracture: mas frac size!"""class custom_factory():    def __init__(self,sigma0):        self.number_of_plots = 3        self.initial_fracture_volume = None        self.tot_vol_line_to_fracture_previous_ts = 0.        self.sigma0 = sigma0/1000000 #MPa        self.data = {'xlabel_1' :'time [s]',                     'ylabel_1': 'pressure [MPa]',                     'xlabel_2': 'time [s]',                     'ylabel_2': 'fracture volume [cm^3]',                     'xdata': [],                     'p_in_crack': [], #, no line injection here                     'p_in_line': [],                     'fracture_volume': [],                     'volume_stored_in_line': [],                     'volume_line_to_fracture': [],                     'injected_volume_cumulative': [],                     'residual_volume':[],                     'tot_leakoff_volume':[],                     'p_in_crack_close_to_center':[]}    def custom_plot(self, plot_index, sim_prop, fig=None):        if plot_index-1 not in range(self.number_of_plots):            print(f"check the variable number_of_plots in the custom class! \n you asked plot {plot_index} but declared number_of_plots={self.number_of_plots}")        if plot_index == 1:            return self.plot_1(sim_prop, fig=fig)        elif plot_index == 2:            return self.plot_2(sim_prop, fig=fig)        elif plot_index == 3:            return self.plot_3(sim_prop, fig=fig)        else:            print(f" you did not code the plot function in the custom class ")    def plot_1(self, sim_prop, fig=None):        # this method is mandatory        if fig is None:            fig = plt.figure()            ax = fig.gca()        else:            ax = fig.get_axes()[0]        ax.scatter(self.data['xdata'], self.data['p_in_line'], color='b', alpha=.5, label='pF in the balloon')        ax.scatter(self.data['xdata'], self.data['p_in_crack'], color='r',marker='*', alpha=.5, label='pF just outside the balloon (crack)')        ax.scatter(self.data['xdata'], self.data['p_in_crack_close_to_center'], color='c', marker='*', alpha=.5, label='pF just next inj. point in crack')        ax.set_xlabel(self.data['xlabel_1'])        ax.set_ylabel(self.data['ylabel_1'])        #ax.set_yscale('log')        #ax.set_xscale('log')        ax.legend()        return fig    def plot_2(self, sim_prop, fig=None):        # this method is mandatory        if fig is None:            fig = plt.figure()            ax = fig.gca()        else:            ax = fig.get_axes()[0]        ax.scatter(self.data['xdata'], self.data['fracture_volume'], color='g', label='fr. vol.', alpha=.5)        ax.scatter(self.data['xdata'], self.data['volume_stored_in_line'], color='r', label='tot vol. stored in balloon', alpha=.5)        ax.scatter(self.data['xdata'], self.data['injected_volume_cumulative'], color='b', label='tot inj. vol.', alpha=.5)        ax.scatter(self.data['xdata'], self.data['volume_line_to_fracture'], color='m', label='tot vol. balloon to frac. ',marker='*', alpha=.5)        ax.scatter(self.data['xdata'], self.data['tot_leakoff_volume'], color='c', label='tot vol. leakoff ', marker='*', alpha=.5)        ax.scatter(self.data['xdata'], self.data['residual_volume'], color='k', label='should be 0',marker='*', alpha=.5)        ax.set_xlabel(self.data['xlabel_2'])        ax.set_ylabel(self.data['ylabel_2'])        ax.legend()        #ax.set_yscale('log')        ax.set_xscale('log')        return fig    def plot_3(self, sim_prop, fig=None):        # this method is mandatory        if fig is None:            fig = plt.figure()            ax = fig.gca()        else:            ax = fig.get_axes()[0]        ax.scatter(self.data['xdata'], self.data['p_in_line']-self.sigma0, color='b', alpha=.5, label='pNet in the balloon')        ax.scatter(self.data['xdata'], self.data['p_in_crack']-self.sigma0, color='r',marker='*', alpha=.5, label='pNet just outside the balloon (crack)')        ax.scatter(self.data['xdata'], self.data['p_in_crack_close_to_center']-self.sigma0, color='c', marker='*', alpha=.5, label='pNet just next inj. point in crack')        ax.set_xlabel(self.data['xlabel_1'])        ax.set_ylabel(self.data['ylabel_1'])        #ax.set_yscale('log')        #ax.set_xscale('log')        ax.legend()        return fig    def postprocess_fracture(self, sim_prop,solid_prop,fluid_prop,injection_prop,fr):        # this method is mandatory        if len(fr.closed)>1:            print("here")        self.data['xdata'].append(fr.time)        self.data['p_in_line'].append(fr.pInjLine/1000000)        ID= fr.mesh.locate_element(0.,0.)        ID_left = fr.mesh.NeiElements[ID[0]][0]        self.data['p_in_crack'].append(fr.pFluid[ID[0]] / 1000000) #        self.data['p_in_crack_close_to_center'].append(fr.pFluid[ID_left] / 1000000)        fracture_volume= np.sum(fr.w)*fr.mesh.hx*fr.mesh.hy        self.data['fracture_volume'].append(fracture_volume*100*100*100)        if self.initial_fracture_volume is None:            self.initial_fracture_volume = fracture_volume        volume_stored_in_line = injection_prop.ILVolume + (+ fr.pInjLine - injection_prop.initPressure ) * injection_prop.ILCompressibility * injection_prop.ILVolume        self.data['volume_stored_in_line'].append(volume_stored_in_line * 100 * 100 * 100)        tot_vol_line_to_fracture = self.tot_vol_line_to_fracture_previous_ts + sum(fr.injectionRate) * fr.timeStep_last        self.data['volume_line_to_fracture'].append(tot_vol_line_to_fracture   * 100 * 100 * 100)        self.tot_vol_line_to_fracture_previous_ts = tot_vol_line_to_fracture        self.data['injected_volume_cumulative'].append(fr.injectedVol * 100 * 100 * 100)        self.data['tot_leakoff_volume'].append(fr.LkOffTotal * 100 * 100 * 100)        self.data['residual_volume'].append((fr.injectedVol + injection_prop.ILVolume - fracture_volume - volume_stored_in_line - fr.LkOffTotal )* 100 * 100 * 100+1)        fr.postprocess_info = self.data        return fr# --------------------------------------------------------------# define the terminating criterion functionclass terminating_criterion_factory:    def __init__(self, min_number_of_open_elemts, finalTime, intermediateTime):        self.min_number_of_open_elemts = min_number_of_open_elemts        self.finalTime = finalTime  # target final time that can be reached during the simulation        self.intermediateTime = intermediateTime        self.did_you_paused = False        self.user_answer = False # meaning that we continue    def ask_question(self, message=''):        # pause the simulation and wait for user answer        user_answer = input(message+'\n Would you like to continue? Y/N ')        if user_answer == 'N':            self.user_answer = True    def __call__(self, fracture):        """ The implementing the terminating_criterion        return True to continue        return False to stop the entire simulation        """        if fracture.time > self.intermediateTime and self.did_you_paused == False:            message = 'Intermediate time reached'            self.ask_question(message)            #update the history variable            self.did_you_paused = True        # open_cells = len(fracture.EltCrack) - len(fracture.closed)        # if open_cells < self.min_number_of_open_elemts:            # message = 'min num. of open elems. reached'            # self.ask_question(message)        if self.user_answer == False and fracture.time < self.finalTime :            return True        else:            return Falserun = Truerestart = Falseif run:    # creating mesh    Mesh = CartesianMesh(0.5, 0.5, 91, 91)    # formation properties - base COx properties    nu = 0.3                            # Poisson's ratio    youngs_mod = 7e9                 # Young's modulus    Eprime = youngs_mod / (1 - nu**2)   # plain strain modulus    K1c = 1e6        # leakoff to match time to close (450s)    Cprime = 0. #1.e-6    # material properties    Solid = MaterialProperties(Mesh,                           Eprime,                           K1c,                           confining_stress=12.5e6,                           minimum_width=1.e-8,#7,                           Carters_coef=Cprime,                           Carters_t0=None)    # # injection parameters 500ml/minute at the pump, CNTP (shall be modified later on), 5 minutes after the break    # Q0 = np.asarray([[0.,     6200,   6800,    10009.4,  15238,    15408, 41238],    #                  [8.3e-6, 0.,     -5e-5,   0.,       +2.5e-5,  0,     0.]])  # injection rate    #    # # Q0 = np.asarray([[0., 6200, 6800, 6810],    # #                  [8.3e-6, 0., -5e-3,0.]])  # injection rate    #    # my_fixed_ts = np.asarray([[0.,   2600.,     2600.006,    2600.01,   2600.051,   2601., 2610, 3000.,6650., 6750., 6800., 6801.,9909.4, 10009.4, 15100, 15308, 15508],    #                           [100., 2*0.00005, 1*0.0004,    2*0.0016,  2*0.01,     1.,    10.,  100., 50,    1,     0.1,   25.,  5,      100,     1,     1,     None]])    # Q0 = np.asarray([[0.,     6200,  6800,  10009.4, 12238,    13708, 41238],    #                  [8.3e-6, 0.,   -5e-5,  0.,      +2.5e-5,  0,     0.]])  # injection rate    Q0 =np.asarray([[0.,     8200,  9800,  10009.4, 12238,    13708, 41238],                    [12.3e-3, 0.,   -5e-3,  0.,      +2.5e-5,  0,     0.]])  # injection rate    Q0 =np.asarray([[0.,     5200,  10800,  10850, 12238,    13708, 41238],                    [18.3e-3, 0.,   -215e-3,  0.,      +2.5e-5,  0,     0.]])  # injection rate with stop    # Q0 =np.asarray([[0.,     8200,  9800,  9919.4, 12238,    13708, 41238],    #                 [18.3e-3, 0.,   -85e-3,  0.,      +2.5e-5,  0,     0.]])  # injection rate without stop    my_fixed_ts = np.asarray([[0.,   15000., 10750, 17109.4, 22000, 22380, 22408, 23808,  24000],                              [100., 100,       5,      50,     10,   1,     10,    100 ,   None]])    # No injection line for now    #Injection = InjectionProperties(Q0, Mesh)    Injection = InjectionProperties(Q0, Mesh, model_inj_line=True,                                   il_compressibility=3e-5,                                   il_volume=1e-3,                                   perforation_friction = 0.,                                   initial_pressure = 15.e6)    # fluid properties - no compressibility for now    #viscosity = 17.5e-6    viscosity = 0.0001    Fluid = FluidProperties(viscosity=viscosity, compressibility=5.51*10-11)#5.51*10-10)    ## simulation properties    simulProp = SimulationProperties()    simulProp.plotTSJump =5 #5                               # save and plot after every 5 time steps    simulProp.set_outputFolder("./Data/radial_base")     # the disk address where the files are saved    simulProp.set_simulation_name('radial_viscosity_pulse_gas_andra_leakoff')    # plotting on the fly    simulProp.customPlotsOnTheFly = True    simulProp.custom = custom_factory(Solid.SigmaO.max())    #simulProp.plotVar = ['ir', 'w', 'custom']    simulProp.plotVar = [ 'w', 'pf', 'custom' ]    simulProp.plotFigure = True    # define the terminating criterion function    min_number_of_open_elemts = 200    finalTime = 60000    intermediateTime = 116801    simulProp.finalTime =  finalTime                              # the time at which the simulation stops    simulProp.terminating_criterion = terminating_criterion_factory(min_number_of_open_elemts, finalTime, intermediateTime)    # front advancement    simulProp.frontAdvancing = 'explicit'    simulProp.maxFrontItrs = 50        # time stepping    simulProp.fixedTmStp = my_fixed_ts    simulProp.tmStpPrefactor= 0.8 # underrelaxation of automatic time step    simulProp.gmres_tol=1.e-12    # solver    simulProp.maxSolverItrs = 500    # use iterative solver - only without injection line    simulProp.EHL_iter_lin_solve = False    simulProp.solve_monolithic = False    simulProp.gmres_Restart = 1000    simulProp.gmres_maxiter = 1000    # initializing fracture    Fr_geometry = Geometry('radial', radius=0.1)    # building elasticity matrix    simulProp.useBlockToeplizCompression = True    from solid.elasticity_isotropic import load_isotropic_elasticity_matrix_toepliz    C = load_isotropic_elasticity_matrix_toepliz(Mesh, Eprime)    #C = load_isotropic_elasticity_matrix(Mesh, Eprime)    init_param = InitializationParameters(Fr_geometry, regime='static',                                      net_pressure=1.e3, width=1.e-2 ,elasticity_matrix=C, time=1)    # creating fracture object    Fr = Fracture(Mesh,                  init_param,                  Solid,                  Fluid,                  Injection,                  simulProp)    if restart:        from utilities.postprocess_fracture import load_fractures        Fr_list, properties = load_fractures("./Data/radial_base",                                             sim_name='radial_viscosity_pulse_gas_andra_leakoff',                                             load_all = True)        #define the time from where to restart        mytime = 5000.        mytime = -1        if mytime == -1:            ID = -1        else:            for i in range(len(Fr_list)):                if Fr_list[i].time > mytime:                    ID = i-1                    if ID<0: ID = 0                    break        Solid, Fluid, Injection, simulProp = properties        # define the terminating criterion function        #min_number_of_open_elemts = 49        #finalTime = 60000        #intermediateTime = 3100        #simulProp.finalTime = finalTime  # the time at which the simulation stops        #simulProp.terminating_criterion = terminating_criterion_factory(min_number_of_open_elemts, finalTime, intermediateTime)        if mytime != -1:            simulProp.EHL_iter_lin_solve = False            simulProp.frontAdvancing = 'explicit'            simulProp.set_outputFolder("./Data/radial_restarted")            # injection parameters 500ml/minute at the pump, CNTP (shall be modified later on), 5 minutes after the break            Q0 = np.asarray([[0.,     6200, 6800,   10009.4, 15238,   15408, 41238],                             [8.3e-6, 0.,   -5e-5,  0.,      +2.5e-5, 0,     0.]])  # injection rate            # Q0 = np.asarray([[0., 6200, 6800, 6810],            #                  [8.3e-6, 0., -5e-3,0.]])  # injection rate            my_fixed_ts = np.asarray([[0.,   2600.,       2600.006,   2600.01,    2600.051, 2601., 2610, 3000., 5150.,5650., 6799., 6800., 6801., 9909.4, 10109.4, 15100, 15308, 15508],                                      [100., 2 * 0.00005, 1 * 0.0004, 2 * 0.0016, 2 * 0.01, 1.,    10.,  100.,  50,   40,    1,     0.1,   25.,   5,      50,     1,     1,     None]])            simulProp.fixedTmStp = my_fixed_ts            # No injection line for now            # Injection = InjectionProperties(Q0, Mesh)            Injection = InjectionProperties(Q0, Mesh, model_inj_line=True,                                            il_compressibility=3e-5,                                            il_volume=1e-3,                                            perforation_friction=0.,                                            initial_pressure=15.e6)        Fr = Fr_list[ID]        print(f' Restart time : {Fr.time}')    # create a Controller    controller = Controller(Fr,                            Solid,                            Fluid,                            Injection,                            simulProp)# run the simulation    controller.run()##################### plotting results #####################plot = Trueif plot :    from utilities.visualization import *    from utilities.postprocess_fracture import load_fractures    if restart == True :        results_folder = "./Data/radial_restarted"    if restart == False :        results_folder = "./Data/radial_base"    Fr_list_complete, properties = load_fractures(results_folder,                                         sim_name='radial_viscosity_pulse_gas_andra_leakoff')    Solid, Fluid, Injection, simulProp = properties    time_srs = get_fracture_variable(Fr_list_complete,'time')    plot_f = custom_factory(Solid.SigmaO.max())    plot_f.data = Fr_list_complete[-1].postprocess_info    plot_f.custom_plot(1, simulProp)    plot_f.custom_plot(2, simulProp)    plot_f.custom_plot(3, simulProp)    mean_distance_to_open_fr = np.zeros(len(time_srs))    # it works only for a single point source    # define the expected  center of the fracture    injection_loc = np.asarray([0, 0])    # from utilities.utility import plot_as_matrix    # K = np.zeros(fr_i.mesh.NumberOfElts)    # K[first_closed] = 1    # K[fr_i.closed] = 3    # K[open_cells] = 6    # K[fr_i.EltTip] = 2    # plot_as_matrix(K, fr_i.mesh)    for i in range(len(Fr_list_complete)):        fr_i= Fr_list_complete[i]        open_cells = np.setdiff1d(fr_i.EltCrack,fr_i.closed)        open_cells = np.setdiff1d(open_cells, fr_i.EltTip)        Nei_Open = fr_i.mesh.NeiElements[open_cells,:].flatten()        Nei_Open = np.unique(Nei_Open)        first_closed = np.setdiff1d(Nei_Open, open_cells)        if len(fr_i.closed) == 0:            front_coord = fr_i.Ffront[:,[0,1]]            n_of_points = front_coord.shape[0]            distances = np.zeros(n_of_points)            for ii in range(n_of_points):                front_coord[ii] = front_coord[ii] - injection_loc                distances = np.sqrt(front_coord[ii][0]**2 + front_coord[ii][1]**2)            mean_distance_to_open_fr[i] = np.mean(distances)        else:            first_closed_centers = fr_i.mesh.CenterCoor[first_closed]            n_of_points = first_closed_centers.shape[0]            distances = np.zeros(n_of_points)            for ii in range(n_of_points):                first_closed_centers[ii] = first_closed_centers[ii] - injection_loc                distances = np.sqrt(first_closed_centers[ii][0]**2 + first_closed_centers[ii][1]**2) - fr_i.mesh.cellDiag/2.            mean_distance_to_open_fr[i] = np.mean(distances)    # plot mean radius of open fracture    fig = plt.figure()    ax = fig.gca()    ax.scatter(time_srs, mean_distance_to_open_fr, color='b', marker='*')    ax.set_xlabel('time [s]')    ax.set_ylabel('mean radius open fracture [m]')    # plot number of closed elems.    n_of_closed = np.zeros(len(Fr_list_complete))    for i in range(len(Fr_list_complete)):        fr_i= Fr_list_complete[i]        n_of_closed[i]=len(fr_i.closed)    fig = plt.figure()    ax = fig.gca()    ax.scatter(time_srs, n_of_closed, color='b', marker='*')    ax.set_xlabel('time [s]')    ax.set_ylabel('number of closed elems.')    # plot fracture radius on mesh    plot_prop = PlotProperties()    Fr_list = []    for i in range(0,len(Fr_list_complete),1): # the last integer represents "we take 1 out of that number result to plot"        Fr_list.append(Fr_list_complete[i])    Fig_R = plot_fracture_list(Fr_list,                               variable='footprint',                               plot_prop=plot_prop)    Fig_R = plot_fracture_list(Fr_list,                               fig=Fig_R,                               variable='mesh',                               mat_properties=properties[0],                               backGround_param='K1c',                               plot_prop=plot_prop)    # plot fracture radius    plot_prop = PlotProperties()    plot_prop.lineStyle = '.'               # setting the linestyle to point    plot_prop.graphScaling = 'loglog'       # setting to log log plot    label = LabelProperties('d_mean')    label.legend = 'radius'    Fig_R = plot_fracture_list(Fr_list,                                   variable='d_mean',                                   plot_prop=plot_prop) # numerical radius    # plot fracture volume    plot_prop = PlotProperties()    plot_prop.lineStyle = '.'               # setting the linestyle to point    plot_prop.graphScaling = 'loglog'       # setting to log log plot    label = LabelProperties('volume')    label.legend = 'volume'    Fig_R = plot_fracture_list(Fr_list,                                   variable='volume',                                   plot_prop=plot_prop) # numerical radius        # # plot analytical K-vertex solution for radius        # plt_prop = PlotProperties(line_color_anal='b')        # label = LabelProperties('d_mean')        # label.legend = 'K solution'        # Fig_R = plot_analytical_solution(regime='K', #'M',                                         # variable='d_mean',                                         # labels=label,                                         # mat_prop=properties[0],                                         # inj_prop=properties[2],                                         # fluid_prop=properties[1],                                         # time_srs=time_srs,                                         # plot_prop=plt_prop,                                         # fig=Fig_R)        # # plot analytical M-pulse-vertex solution for radius        # plt_prop = PlotProperties(line_color_anal='m')        # label = LabelProperties('d_mean')        # label.legend = 'M-pulse solution'        # Fig_R = plot_analytical_solution(regime='Mp',                                         # variable='d_mean',                                         # labels=label,                                         # mat_prop=properties[0],                                         # inj_prop=properties[2],                                         # fluid_prop=properties[1],                                         # time_srs=time_srs,                                         # plot_prop=plt_prop,                                         # fig=Fig_R)        # # plotting pressure during initial propagation        # #time_srs = np.linspace(10, 600) #, 600)        # Fr_list, properties = load_fractures(".\Data\Pulse",                                         # time_period=5)    # #                                     time_srs=time_srs)        # plot_prop = PlotProperties(line_style='.-')    # plotting pressure at injection point    p_prop = PlotProperties(line_style='.')    Fig_p = plot_fracture_list_at_point(Fr_list,                                        variable='pf',                                        point=[[0, 0]],                                        plot_prop=p_prop)         # plt.show(block=True)        # Fig_Pw_vs_R = plt.plot(get_fracture_variable(Fr_list, 'd_mean', edge=4, return_time=False),                               # get_fracture_variable_at_point(Fr_list, 'pf', [0, 0], edge=4, return_time=False),                               # 'go--')        # plt.show(block=True)        # Fig_Ps = plot_fracture_list_slice(Fr_list,                                      # variable='pf',                                      # plot_cell_center=True,                                      # plot_prop=plot_prop)        # Fig_w = plot_fracture_list_slice(Fr_list,                                      # variable='w',                                      # plot_cell_center=True,                                      # plot_prop=plot_prop)        # # plot slice of width        # time_slice = np.asarray([0.5, 1, 5, 10, 50, 300]) # 45, 5e4, 5e5, 5e6])        # Fr_slice, properties = load_fractures(address="./Data/pulse",                                              # time_srs=time_slice)       # load specific fractures        # time_slice = get_fracture_variable(Fr_slice,                                           # variable='time')        # ext_pnts = np.empty((2, 2), dtype=np.float64)        # Fig_WS_M = plot_fracture_list_slice(Fr_slice[3:],                                          # variable='w',                                          # projection='2D',                                          # plot_cell_center=True,                                          # extreme_points=ext_pnts)        # # plot slice of width analytical        # #Fig_WS_M = plot_analytical_solution_slice('K', #'M',        # #                                        'w',        # #                                        Solid,        # #                                        Injection,        # #                                        time_srs=time_slice[3:],        # #                                        fluid_prop=Fluid,        # #                                        fig=Fig_WS_M,        # #                                        point1=ext_pnts[0],        # #                                        point2=ext_pnts[1])        # ext_pnts = np.empty((2, 2), dtype=np.float64)    # #    Fig_WS_Mp = plot_fracture_list_slice(Fr_slice[3:],    # #                                      variable='w',    # #                                      projection='2D',    # #                                      plot_cell_center=True,    # #                                      extreme_points=ext_pnts)        # # plot slice of width analytical    # #    Fig_WS_Mp = plot_analytical_solution_slice('Mp',    # #                                            'w',    # #                                            Solid,    # #                                            Injection,    # #                                            time_srs=time_slice[3:],    # #                                            fluid_prop=Fluid,    # #                                            fig=Fig_WS_Mp,    # #                                            point1=ext_pnts[0],    # #                                            point2=ext_pnts[1])        # # plot slice of pressure    # #    ext_pnts = np.empty((2, 2), dtype=np.float64)    # #    Fig_PS_M = plot_fracture_list_slice(Fr_slice[:3],    # #                                      variable='pn',    # #                                      projection='2D',    # #                                      plot_cell_center=True,    # #                                      extreme_points=ext_pnts)        # # plot slice of width analytical    # #    Fig_PS_M = plot_analytical_solution_slice('M',    # #                                            'pn',    # #                                            Solid,    # #                                            Injection,    # #                                            time_srs=time_slice[:3],    # #                                            fluid_prop=Fluid,    # #                                            fig=Fig_PS_M,    # #                                            point1=ext_pnts[0],    # #                                            point2=ext_pnts[1])        # ext_pnts = np.empty((2, 2), dtype=np.float64)    # #    Fig_PS_Mp = plot_fracture_list_slice(Fr_slice[3:],    # #                                      variable='pn',    # #                                      projection='2D',    # #                                      plot_cell_center=True,    # #                                      extreme_points=ext_pnts)        # # plot slice of width analytical    # #    Fig_PS_Mp = plot_analytical_solution_slice('Mp',    # #                                            'pn',    # #                                            Solid,    # #                                            Injection,    # #                                            time_srs=time_slice[3:],    # #                                            fluid_prop=Fluid,    # #                                            fig=Fig_PS_Mp,    # #                                            point1=ext_pnts[0],    # #                                            point2=ext_pnts[1])    plt.show(block=True)